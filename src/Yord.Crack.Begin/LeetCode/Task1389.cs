using System;

namespace Yord.Crack.Begin.LeetCode
{
    //https://leetcode.com/problems/create-target-array-in-the-given-order/discuss/695423/O(NLogN)-Java-Solution-using-Merge-Sort-with-Pen-Paper-Explanation
    // создать массив по правилам: вставать nums[i]  в индекс index[i]. Все числа - неотрицательные
    public class Task1389
    {
        public static int[] CreateTargetArray(int[] nums, int[] index)
        {
            int[] target = new int[nums.Length];
            int c = 0;
            while (c < target.Length)
            {
                if (index[c] < c) // если ставим в ячейку левее текущей, то есть замена, нужно освободить место
                {
                    // от конца до предтекущего - сдвигаем вправо
                    for (int i = target.Length - 1; i > index[c]; i--)
                    {
                        target[i] = target[i - 1];
                    }
                }

                target[index[c]] = nums[c];
                c++;
            }

            return target;
        }

        // идем по массиву с индексами. если для текущего индекса слева есть индекс, который больше либо равен текущему,
        // значит будет замена и такие индексы надо подвинуть на +1
        // то есть если перед текущей вставкой уже была вставка, которая  была в тот же индекс или правее
        // (т.к. даже чтобы вставить в текущее окно, нужно будет сдвинуть их на +1, значит их затронет любая вставка),
        // значит нужно такие индексы сдвинуть заранее, подвинув их на +1.
        // АЛЬТЕРНАТИВНО:
        // Если находим справа индекс меньший либо равный текущему, то увеличиваем текущий на 1 тут же, например
        // [0, 0, 1] => 
        // сравниваем первый 0 со вторым, второй <= первому, первый +1 => [1,0,1].
        // сравниваем первую единицы с третьей. третья <=первой, первая единица +1 => [2,0,1]
        // повторяем для всех оставшихся индексов
        public static int[] CreateTargetArray_SmallerSelf(int[] nums, int[] index)
        {
            int n = nums.Length;
            int[] a = new int [n];
            for (int i = 0; i < n; ++i)
            {
                a[i] = i;
            }

            GetRealIndex(a, 0, n, index, new int[n]);
            int[] r = new int [n];
            for (int i = 0; i < n; ++i)
            {
                r[index[i]] = nums[i];
            }

            return r;
        }

        //  получение реальных индексов. по сути - сортировка слиянием
        private static void GetRealIndex(int[] a, int i, int j, int[] index, int[] tmp)
        {
            if (j - i <= 1) return; // кол-во элементов в списке 0 или 1, значит список уже отсортирован
            // количество элементов больше одного
            int k = (i + j) >> 1; // середина
            GetRealIndex(a, i, k, index, tmp); // отсортируем левую половину
            GetRealIndex(a, k, j, index, tmp); // отсортируем правую половину
            int x = i; //левый индекс
            int y = k; // середина
            int z = 0; //индекс во временном массиве
            int c = 0; // кол-во шагов
            while (x < k && y < j) // пока левый индекс не дошел до середины и правый индекс не дошел до конца
            {
                // пока правый индекс не дошел до конца
                // и индекс справа меньше, чем индекс слева (т.е. пока понимаем, что нужен сдвиг)
                // увеличиваем индексы до нужных
                while (y < j && index[a[y]] <= index[a[x]] + c)
                {
                    c++; //увеличиваем кол-во прибавляемых шагов
                    tmp[z++] = a[y++]; // копируем индексы по порядку и переходим к следующим 
                }

                // либо дошли до конца справа, либо индекс справа стал меньше, чем индекс в левой части
                // (время добавить кол-во полученных шагов) к каждому индексу слева 
                index[a[x]] += c; // добавим к индексу слева кол-во шагов
                tmp[z++] = a[x++]; //снова скопируем и перейдем к следующему
            }
            
            while (x < k) // пока слева не дошли до середины
            {
                index[a[x]] += c; // добавляем к левому индексу кол-во шагов
                tmp[z++] = a[x++]; // копируем и переходим к следующему
            }
            
            while (y < j) //пока в правой половине не дошли до конца
            {
                tmp[z++] = a[y++]; //копируем правую половину
            }

            int p = i;
            int q = 0;

            //копируем отсортированный кусок из временного массива в результирующий
            for (; p < j; ++p, ++q)
            {
                a[p] = tmp[q];
            }
        }
    }
}
